### java 中堆内存与栈内存

Java把内存分为两种：**栈内存**和**堆内存**

在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当一段代码块中定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作他用。

堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机自动垃圾回收器来管理。在堆中产生一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊变量就变成了数组或者对象的**引用变量**。以后就可以在程序中使用栈内存中的这个引用变量来访问堆内存中的对象或者数组，引用变量相当于为数组或者对象起的一个别名，或者代号。

引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组、对象本身在堆中分配，即使程序运行到使用new产生数组或者对象的语句所在的代码之外，数组和对象本身占有的对内存也不会释放。数组和对象在没有引用变量指向它的时候，才变成垃圾，不能被使用，但仍然占用这内存，在随后的一个不确定的时间被垃圾回收器释放掉。实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针。

### Java中内存分配策略及堆和栈的比较

#### 1. 内存分配策略

按照编译原理的观点，程序运行时的内存分配有三种策略：静态、栈式、堆式

静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求，因而在编译时就可以给他们分配固定的内存空间。这种分配策略要求程序代码中不允许有可变的数据结构（比如可变数组）的存在，也不允许有嵌套或者递归结构的出现，因为他们都能导致编译程序无法计算准确的存储空间需求。

栈式存储分配也可称为动态存储分配，是由一个类似于堆栈的运行时栈来实现的。和静态存储分配相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到运行时才能够知道，但是规定在运行时进入一个程序模块时，必须知道该程序模块所需的数据区的大小才能够为其分配内存。和数据结构中的栈一样，栈式分配按照先进后出的原则进行分配。

静态存储分配要求在编译时能知道所有变量的存储需求，栈式存储分配要求在过程的入口处必须知道所有的存储要求，而堆式存储分配专门负责在编译或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。

#### 2. 堆和栈的比较

从堆和栈的功能和作用来通俗的比较，堆主要是用来存放对象的，栈主要用了存放执行程序的。而这种不同又主要是通过堆和栈的特点决定的。

在编程中，例如C/C++中，所有的方法的调用都是通过栈来进行的，所有的局部变量、形式参数都是从栈中分配内存空间的。实际上也不是什么分配，只是从栈顶向上调用就行，就好像工厂中的传送带一样。Stack Point会自动指引你放东西的位置，你所要做的就是把东西放下来就行，退出函数的时候，修改栈指针就可以把栈中的内容销毁，这样模式的速度最快，当然要用来运行程序了。需要注意的是，在分配的时候，比如为一个即将要调用的程序模块分配数据区时应事先知道这个数据区的大小，也就是说虽然分配是在程序运行时进行的，但是分配的大小是多少是确定的，不变的，而这个大小是在编译时确定的，不是在运行时。

堆是应用程序在运行的时候请求操作系统分配给自己的内存，由于是从操作系统管理的内存分配，所有在分配和销毁时都要占用时间，因此用堆的效率非常低。但是堆的优点在于，编译器不必知道要从堆里分配多少存储空间，也不知道存储的数据要在堆里存放多长时间，因此，用堆保存数据时会得到更大的灵活性。事实上，面向对象的多态性，堆内存分配是必不可少的，因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定。在C++中，要创建一个对象时，只需要用new命令编写相关代码即可。执行这些代码时，会在堆中自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定代价：在堆中分配存储空间时会花掉更多的时间。这也是导致效率低的原因。

#### 3. JVM中的堆和栈

JVM是基于栈的虚拟机。JVM为每个新创建的线程都分配一个栈，也就是说，对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态，JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。

某个线程正在执行的方法称为此线程的当前方法，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的Java栈里新压入一个帧，这个帧就是当前帧，在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。

从Java的这种分配机制来看，栈又可以这样理解：栈（Stack）是操作系统在建立某个进程时或者线程为这个线程建立的存储区域，该区域具有先进后出的特性。

每个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用所有的线程共享，跟C/C++中的不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在栈中分配，也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际创建这个对象，而在栈中分配的内存只是一个指向这个堆对象的引用而已。

#### Java中的堆和栈

Java把内存划分为两种：栈内存和堆内存

在函数中定义的一些基本类型的变量和对象引用都在函数的栈内存中分配

当一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个变量，让这个变量的取值等于对象或者数组在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。

Java堆是一个运行时数据区，类的对象从中分配空间。这些对象通过new等指令建立，不需要程序代码来显示释放。堆由垃圾回收来负责。堆的优势可以动态的分配内存大小，生存期也不用事先告诉编译器，因为它是运行时动态分配内存的，Java的垃圾收集器会自动回收这些不再使用的数据。缺点是要在运行时动态分配内存，存取速度较慢。

栈的优势是，存取速度比堆快，仅次于寄存器，栈数据可以共享。但缺点是：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量和对象句柄。




**来源：博客园**
链接：http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html
